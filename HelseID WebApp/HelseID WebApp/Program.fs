module HelseID_WebApp.App

open System
open System.IdentityModel.Tokens.Jwt

open Microsoft.AspNetCore.Authentication
open Microsoft.AspNetCore.Http
open Microsoft.AspNetCore.Builder
open Microsoft.AspNetCore.Hosting

open Microsoft.Extensions.Hosting
open Microsoft.Extensions.Logging
open Microsoft.Extensions.DependencyInjection


open FSharp.Control.Tasks.V2.ContextInsensitive     //This needs IdentityModel4
open Giraffe
open Giraffe.ViewEngine

open HelseID_WebApp.HttpsConfig
open HelseID_WebApp.Settings
let settings = Settings._Settings       //opening configurable settings. Not as json, but this can be changed (to get settings from appsettings.json)

// ---------------------------------
// Web app
// ---------------------------------

module AuthSchemes =

    let cookie  = "Cookies"
    let OIDC    = "oidc"

module Urls =

    let index      = "/"
    let login      = "/login"
    let user       = "/user"
    let logout     = "/logout"
    let missing    = "/missing"
    let helseIdAuth = "/helse-id-auth"
    let callback    = "/callback"

    let signinCallback = "/signin-oidc"     //DO NOT CHANGE THIS. THE "/signin-oidc" URL IS AUTO GENERATED BY THE OIDC SIGNIN SCHEME, BUT IS HERE FOR REFERENCE ONLY


module Views =  //Simple web pages written in XML
    
    let master (content: XmlNode list) =
        html [] [
            head [] [
                title [] [ str "HelseID Sample App" ]
            ]
            body [] content
        ]

    let index =
        [
            h1 [] [ str "HelseID Sample App" ]
            p [] [ str "Welcome to the HelseID Sample App!" ]
            ul [] [
                li [] [ a [ _href Urls.login ] [ str "Login" ] ]
                li [] [ a [ _href Urls.user ] [ str "User profile" ] ]
            ]
        ] |> master

    let login =
        [
            h1 [] [ str "Login" ]
            p [] [ str "Pick one of the options to log in:" ]
            ul [] [
                li [] [ a [ _href Urls.helseIdAuth ] [ str "HelseID m/ OIDC" ] ]
            ]
            p [] [
                a [ _href Urls.index ] [ str "Return to home." ]
            ]
        ] |> master

    let user (claims : (string * string) seq) =
        [
            h1 [] [ str "User details" ]
            h2 [] [ str "Claims:" ]
            ul [] [
                yield! claims |> Seq.map (
                    fun (key, value) ->
                        li [] [ sprintf "%s: %s" key value |> str ] )
            ]
            p [] [
                a [ _href Urls.logout ] [ str "Logout" ]
                li [] [ a [ _href Urls.index ] [ str "Return to home." ] ]
                
            ]
        ] |> master

    let notFound =
        [
            h1 [] [ str "Not Found" ]
            p [] [ str "The requested resource does not exist." ]
            ul [] [
                li [] [ a [ _href Urls.index ] [ str "Return to home." ] ]
            ]
        ] |> master




module Handlers =
    let setHttpHeader key value : HttpHandler =
        fun (next : HttpFunc) (ctx : HttpContext) ->
            ctx.SetHttpHeader (key , value)
            next ctx
    
    let index : HttpHandler = Views.index |> htmlView
    let login : HttpHandler = Views.login |> htmlView


    let user : HttpHandler =
        fun (next : HttpFunc) (ctx : HttpContext) ->
            (ctx.User.Claims
            |> Seq.map (fun c -> (c.Type, c.Value))
            |> Views.user
            |> htmlView) next ctx

    let challenge (scheme : string) (redirectUri : string) : HttpHandler =
        fun (next : HttpFunc) (ctx : HttpContext) ->
            task {
                let prop = new AuthenticationProperties(RedirectUri = redirectUri)
            
                do! ctx.ChallengeAsync(
                        scheme,
                        prop)

                return! next ctx
            }
        
    let logout : HttpHandler =
        signOut AuthSchemes.cookie
        >=> signOut AuthSchemes.OIDC 
        >=> signOut AuthSchemes.cookie      //"auth-session" cookie is not deleted (?)
        

    let helseIdAuth = challenge AuthSchemes.OIDC Urls.user

    let authenticate : HttpHandler =
        requiresAuthentication login            //Giraffe automatic Middleware. Might have to design another type of middleware to check if the tokens/cookies are legit.

    let notFound : HttpHandler =
        setStatusCode 404 >=>
        (Views.notFound |> htmlView)

    let webApp : HttpHandler =
        choose [
            GET >=>
                choose [
                    route Urls.index        >=> index
                    route Urls.login        >=> login
                    route Urls.user         >=> authenticate >=> user   //Access Protected Resource after SSO
                    route Urls.logout       >=> logout
                    route Urls.helseIdAuth  >=> helseIdAuth
                ]
            notFound ]

    let error (ex : Exception) (logger : ILogger) =
        logger.LogError(EventId(), ex, "An unhandled exception has occurred while executing the request.")
        clearResponse >=> setStatusCode 500 >=> text ex.Message

// ---------------------------------
// Config and Main
// ---------------------------------

//Config has been done in a functional way. Can be also be done by plugging the web app into the ASP.NET middleware. See https://github.com/giraffe-fsharp/Giraffe/blob/master/DOCUMENTATION.md#basics

let configureApp (app : IApplicationBuilder) =
    app.UseGiraffeErrorHandler(Handlers.error)
       .UseHttpsRedirection()
       .UseStaticFiles()
       .UseRouting() //?
       .UseAuthentication()
       .UseSession()
       .UseResponseCaching()    
       .UseGiraffe Handlers.webApp      //If you are going to use MVC, you can configure it with .UseMvc instead
       

let configureServices (services : IServiceCollection) =
    //create a singleton from settings instance?
    
    //adding response caching
    services.AddResponseCaching()
            .AddGiraffe()
            |> ignore
    services.AddDistributedMemoryCache() |> ignore
    services.AddSession() |> ignore

    JwtSecurityTokenHandler.DefaultInboundClaimTypeMap.Clear() |> ignore
    // Enable Authentication providers
    services.AddAuthentication(fun o ->
                    o.DefaultScheme <- AuthSchemes.cookie
                    o.DefaultChallengeScheme <- AuthSchemes.OIDC)
            .AddCookie(
                AuthSchemes.cookie, fun o ->
                    o.LoginPath  <- PathString Urls.login
                    o.LogoutPath <- PathString Urls.logout)
            .AddOpenIdConnect(
                AuthSchemes.OIDC, fun o ->
                    o.SignInScheme <- settings.SignInScheme
                    o.SignOutScheme <- settings.SignOutScheme
                    o.RequireHttpsMetadata <- true 
                    o.SaveTokens <- true
                    o.GetClaimsFromUserInfoEndpoint <- true

                    o.Authority <- settings.Authority
                    o.ClientId <- settings.ClientId
                    o.ClientSecret <- settings.ClientSecret
                    o.ResponseType <- settings.ResponseType
                    o.Scope.Add("openid")
                    o.Scope.Add("profile")
                    //o.Scope.Add(settings.Scope)   //alternatively add the full list of scopes

                    o.SignedOutRedirectUri <- settings.SignedOutRedirectUri
                    o.TokenValidationParameters.SaveSigninToken <- true
                    o.UsePkce <- true
                    o.CallbackPath <- PathString Urls.signinCallback        //  Important: Configure this endpoint to among your "Redirect URIs" on the HelseID Admin Page
                                                                            //  This is where the webapp will return after logging in. 

                    o.SignedOutCallbackPath <- PathString Urls.callback     //  Important: Configure this endpoint to be among your "Post logout redirect URIs" on the HelseID Admin page.
                                                                            //  Also, remember that this endpoint cannot be referred to anywhere else as the OIDC signout function occupies
                                                                            //      an endpoint, hence "disabling" the HTML View at that endpoint. Therefore: Make sure the Urls.callback is 



                       
                    
                    )
            |> ignore

    // Add framework services. 
    services.AddGiraffe() |> ignore
                //If you want to use razor view pages with HTML instead of XML pages:
                //services.AddControllersWithViews().AddRazorRuntimeCompilation() |> ignore
                //services.AddRazorPages() |> ignore
                
let configureLogging (builder : ILoggingBuilder) =
    let filter (l : LogLevel) = l.Equals LogLevel.Error
    builder.AddFilter(filter)
           .AddConsole()
           .AddDebug()
    |> ignore

// This method gets called by the runtime. Use this method to configure the HTTP request pipeline.      
[<EntryPoint>]
let main _ =
    let endpoints =
        [
            EndpointConfiguration.Default           //This can be used to set up a HTTPS Certificate, so that you can use Kestrel and run the server
            (* { EndpointConfiguration.Defaultwith
                Port            = Some 44340
                Scheme          = Https
                FilePath        = Some "C:\Users\danielh\AppData\Roaming\Microsoft\SystemCertificates\My\Certificates\450D0F72959EA7080E82F0073F9106667346A086"
                Password        = Some "RJFAS25"
                StoreName       = Some "My"
                StoreLocation   = Some "Location"}*)]

    Microsoft.Extensions.Hosting.Host.CreateDefaultBuilder()
        .ConfigureWebHostDefaults(
            fun webHostBuilder ->
                webHostBuilder.UseIISIntegration() |> ignore
                webHostBuilder
                 //   .UseKestrel(fun o -> o.ConfigureEndpoints endpoints)
                    .Configure(configureApp)
                    .ConfigureServices(configureServices)
                    .ConfigureLogging(configureLogging)
                    |> ignore)
        .Build()
        .Run()
    0

